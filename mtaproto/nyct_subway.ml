(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: nyct_subway.proto
  Syntax: proto2
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]

(**/**)

module Imported'modules = struct
  module Gtfs_realtime = Gtfs_realtime
end

(**/**)

module rec TripReplacementPeriod : sig
  val name' : unit -> string

  type t =
    { route_id : string option
    ; replacement_period :
        Imported'modules.Gtfs_realtime.Transit_realtime.TimeRange.t option
    }

  val make
    :  ?route_id:string
    -> ?replacement_period:Imported'modules.Gtfs_realtime.Transit_realtime.TimeRange.t
    -> unit
    -> t

  val to_proto : t -> Runtime'.Writer.t
  val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
end = struct
  let name' () = "nyct_subway.TripReplacementPeriod"

  type t =
    { route_id : string option
    ; replacement_period :
        Imported'modules.Gtfs_realtime.Transit_realtime.TimeRange.t option
    }

  let make ?route_id ?replacement_period () = { route_id; replacement_period }

  let to_proto =
    let apply ~f:f' { route_id; replacement_period } =
      f' [] route_id replacement_period
    in
    let spec =
      Runtime'.Serialize.C.(
        basic_opt (1, string)
        ^:: basic_opt
              ( 2
              , message (fun t ->
                  Imported'modules.Gtfs_realtime.Transit_realtime.TimeRange.to_proto t) )
        ^:: nil)
    in
    let serialize = Runtime'.Serialize.serialize [] spec in
    fun t -> apply ~f:serialize t
  ;;

  let from_proto =
    let constructor _extensions route_id replacement_period =
      { route_id; replacement_period }
    in
    let spec =
      Runtime'.Deserialize.C.(
        basic_opt (1, string)
        ^:: basic_opt
              ( 2
              , message (fun t ->
                  Imported'modules.Gtfs_realtime.Transit_realtime.TimeRange.from_proto t)
              )
        ^:: nil)
    in
    let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
    fun writer -> deserialize writer |> Runtime'.Result.open_error
  ;;
end

and NyctFeedHeader : sig
  val name' : unit -> string

  type t =
    { nyct_subway_version : string
    ; trip_replacement_period : TripReplacementPeriod.t list
    }

  val make
    :  nyct_subway_version:string
    -> ?trip_replacement_period:TripReplacementPeriod.t list
    -> unit
    -> t

  val to_proto : t -> Runtime'.Writer.t
  val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
end = struct
  let name' () = "nyct_subway.NyctFeedHeader"

  type t =
    { nyct_subway_version : string
    ; trip_replacement_period : TripReplacementPeriod.t list
    }

  let make ~nyct_subway_version ?trip_replacement_period () =
    let trip_replacement_period =
      match trip_replacement_period with
      | Some v -> v
      | None -> []
    in
    { nyct_subway_version; trip_replacement_period }
  ;;

  let to_proto =
    let apply ~f:f' { nyct_subway_version; trip_replacement_period } =
      f' [] nyct_subway_version trip_replacement_period
    in
    let spec =
      Runtime'.Serialize.C.(
        basic (1, string, required)
        ^:: repeated (2, message (fun t -> TripReplacementPeriod.to_proto t), not_packed)
        ^:: nil)
    in
    let serialize = Runtime'.Serialize.serialize [] spec in
    fun t -> apply ~f:serialize t
  ;;

  let from_proto =
    let constructor _extensions nyct_subway_version trip_replacement_period =
      { nyct_subway_version; trip_replacement_period }
    in
    let spec =
      Runtime'.Deserialize.C.(
        basic (1, string, required)
        ^:: repeated (2, message (fun t -> TripReplacementPeriod.from_proto t), not_packed)
        ^:: nil)
    in
    let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
    fun writer -> deserialize writer |> Runtime'.Result.open_error
  ;;
end

and NyctTripDescriptor : sig
  module rec Direction : sig
    type t =
      | NORTH
      | EAST
      | SOUTH
      | WEST

    val to_int : t -> int
    val from_int : int -> (t, [> Runtime'.Result.error ]) result
  end

  val name' : unit -> string

  type t =
    { train_id : string option
    ; is_assigned : bool option
    ; direction : NyctTripDescriptor.Direction.t option
    }

  val make
    :  ?train_id:string
    -> ?is_assigned:bool
    -> ?direction:NyctTripDescriptor.Direction.t
    -> unit
    -> t

  val to_proto : t -> Runtime'.Writer.t
  val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
end = struct
  module rec Direction : sig
    type t =
      | NORTH
      | EAST
      | SOUTH
      | WEST

    val to_int : t -> int
    val from_int : int -> (t, [> Runtime'.Result.error ]) result
  end = struct
    type t =
      | NORTH
      | EAST
      | SOUTH
      | WEST

    let to_int = function
      | NORTH -> 1
      | EAST -> 2
      | SOUTH -> 3
      | WEST -> 4
    ;;

    let from_int = function
      | 1 -> Ok NORTH
      | 2 -> Ok EAST
      | 3 -> Ok SOUTH
      | 4 -> Ok WEST
      | n -> Error (`Unknown_enum_value n)
    ;;
  end

  let name' () = "nyct_subway.NyctTripDescriptor"

  type t =
    { train_id : string option
    ; is_assigned : bool option
    ; direction : NyctTripDescriptor.Direction.t option
    }

  let make ?train_id ?is_assigned ?direction () = { train_id; is_assigned; direction }

  let to_proto =
    let apply ~f:f' { train_id; is_assigned; direction } =
      f' [] train_id is_assigned direction
    in
    let spec =
      Runtime'.Serialize.C.(
        basic_opt (1, string)
        ^:: basic_opt (2, bool)
        ^:: basic_opt (3, enum NyctTripDescriptor.Direction.to_int)
        ^:: nil)
    in
    let serialize = Runtime'.Serialize.serialize [] spec in
    fun t -> apply ~f:serialize t
  ;;

  let from_proto =
    let constructor _extensions train_id is_assigned direction =
      { train_id; is_assigned; direction }
    in
    let spec =
      Runtime'.Deserialize.C.(
        basic_opt (1, string)
        ^:: basic_opt (2, bool)
        ^:: basic_opt (3, enum NyctTripDescriptor.Direction.from_int)
        ^:: nil)
    in
    let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
    fun writer -> deserialize writer |> Runtime'.Result.open_error
  ;;
end

and NyctStopTimeUpdate : sig
  val name' : unit -> string

  type t =
    { scheduled_track : string option
    ; actual_track : string option
    }

  val make : ?scheduled_track:string -> ?actual_track:string -> unit -> t
  val to_proto : t -> Runtime'.Writer.t
  val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
end = struct
  let name' () = "nyct_subway.NyctStopTimeUpdate"

  type t =
    { scheduled_track : string option
    ; actual_track : string option
    }

  let make ?scheduled_track ?actual_track () = { scheduled_track; actual_track }

  let to_proto =
    let apply ~f:f' { scheduled_track; actual_track } =
      f' [] scheduled_track actual_track
    in
    let spec =
      Runtime'.Serialize.C.(basic_opt (1, string) ^:: basic_opt (2, string) ^:: nil)
    in
    let serialize = Runtime'.Serialize.serialize [] spec in
    fun t -> apply ~f:serialize t
  ;;

  let from_proto =
    let constructor _extensions scheduled_track actual_track =
      { scheduled_track; actual_track }
    in
    let spec =
      Runtime'.Deserialize.C.(basic_opt (1, string) ^:: basic_opt (2, string) ^:: nil)
    in
    let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
    fun writer -> deserialize writer |> Runtime'.Result.open_error
  ;;
end

and Nyct_feed_header : sig
  type t = NyctFeedHeader.t option

  val get
    :  Imported'modules.Gtfs_realtime.Transit_realtime.FeedHeader.t
    -> (NyctFeedHeader.t option, [> Runtime'.Result.error ]) result

  val set
    :  Imported'modules.Gtfs_realtime.Transit_realtime.FeedHeader.t
    -> NyctFeedHeader.t option
    -> Imported'modules.Gtfs_realtime.Transit_realtime.FeedHeader.t
end = struct
  type t = NyctFeedHeader.t option

  let get extendee =
    Runtime'.Extensions.get
      Runtime'.Deserialize.C.(
        basic_opt (1001, message (fun t -> NyctFeedHeader.from_proto t)) ^:: nil)
      extendee.Imported'modules.Gtfs_realtime.Transit_realtime.FeedHeader.extensions'
    |> Runtime'.Result.open_error
  ;;

  let set extendee t =
    let extensions' =
      Runtime'.Extensions.set
        Runtime'.Serialize.C.(
          basic_opt (1001, message (fun t -> NyctFeedHeader.to_proto t)) ^:: nil)
        extendee.Imported'modules.Gtfs_realtime.Transit_realtime.FeedHeader.extensions'
        t
    in
    { extendee with
      Imported'modules.Gtfs_realtime.Transit_realtime.FeedHeader.extensions'
    }
  ;;
end

and Nyct_trip_descriptor : sig
  type t = NyctTripDescriptor.t option

  val get
    :  Imported'modules.Gtfs_realtime.Transit_realtime.TripDescriptor.t
    -> (NyctTripDescriptor.t option, [> Runtime'.Result.error ]) result

  val set
    :  Imported'modules.Gtfs_realtime.Transit_realtime.TripDescriptor.t
    -> NyctTripDescriptor.t option
    -> Imported'modules.Gtfs_realtime.Transit_realtime.TripDescriptor.t
end = struct
  type t = NyctTripDescriptor.t option

  let get extendee =
    Runtime'.Extensions.get
      Runtime'.Deserialize.C.(
        basic_opt (1001, message (fun t -> NyctTripDescriptor.from_proto t)) ^:: nil)
      extendee.Imported'modules.Gtfs_realtime.Transit_realtime.TripDescriptor.extensions'
    |> Runtime'.Result.open_error
  ;;

  let set extendee t =
    let extensions' =
      Runtime'.Extensions.set
        Runtime'.Serialize.C.(
          basic_opt (1001, message (fun t -> NyctTripDescriptor.to_proto t)) ^:: nil)
        extendee
          .Imported'modules.Gtfs_realtime.Transit_realtime.TripDescriptor.extensions'
        t
    in
    { extendee with
      Imported'modules.Gtfs_realtime.Transit_realtime.TripDescriptor.extensions'
    }
  ;;
end

and Nyct_stop_time_update : sig
  type t = NyctStopTimeUpdate.t option

  val get
    :  Imported'modules.Gtfs_realtime.Transit_realtime.TripUpdate.StopTimeUpdate.t
    -> (NyctStopTimeUpdate.t option, [> Runtime'.Result.error ]) result

  val set
    :  Imported'modules.Gtfs_realtime.Transit_realtime.TripUpdate.StopTimeUpdate.t
    -> NyctStopTimeUpdate.t option
    -> Imported'modules.Gtfs_realtime.Transit_realtime.TripUpdate.StopTimeUpdate.t
end = struct
  type t = NyctStopTimeUpdate.t option

  let get extendee =
    Runtime'.Extensions.get
      Runtime'.Deserialize.C.(
        basic_opt (1001, message (fun t -> NyctStopTimeUpdate.from_proto t)) ^:: nil)
      extendee
        .Imported'modules.Gtfs_realtime.Transit_realtime.TripUpdate.StopTimeUpdate
         .extensions'
    |> Runtime'.Result.open_error
  ;;

  let set extendee t =
    let extensions' =
      Runtime'.Extensions.set
        Runtime'.Serialize.C.(
          basic_opt (1001, message (fun t -> NyctStopTimeUpdate.to_proto t)) ^:: nil)
        extendee
          .Imported'modules.Gtfs_realtime.Transit_realtime.TripUpdate.StopTimeUpdate
           .extensions'
        t
    in
    { extendee with
      Imported'modules.Gtfs_realtime.Transit_realtime.TripUpdate.StopTimeUpdate
      .extensions'
    }
  ;;
end
